---
title: "3. Remote Code Hosting and GitHub"
---

```{r include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

Version control really comes into its own when we begin to collaborate with other people. We already have most of the machinery we need to do this ; the only thing missing is to copy changes from one repository to another.

Systems like Git allow us to move work between two repositories. The repositories can live on separate computers or network locations. In practice, we often use one copy as a central hub, and keep it on the web rather than on someone’s laptop. Most programmers use a hosting service like GitHub to hold the central repositories; and this is true for many BC Government employees.

If you recall, in the pre-workshop, you created a GitHub account and associated it with your GitHub handle (or ID). You also configured your computer with a token (PAT) in a way that should seamlessly allow us to to create a remote repository on GitHub that will be linked to our local repository. Then we will share the changes we’ve made to our current project with the world.

## 3.1 **Creating a Remote Repository**

1.  Log in to GitHub. Your personal dashboard is the first page you'll see when you sign in on GitHub.

    Tip: To access your personal dashboard once you're signed in, click the invertocat ![](images/github-mark.png){width="13"} logo in the upper-left corner of any page on GitHub.

2.  Click on the `+` icon in the top right corner of your personal dashboard, then `New Repository`

3.  Name your repository “planets”. Further down the page are other options available to us that can be toggled to suit the repository's purpose. For this workshop it's fine to create a "Public" repository however since this repository will be connected to a local repository, it needs to be empty. Therefore, leave “Add a README file” unchecked, and select “None” as options for both “Add .gitignore” and “Add a license.”

4.  Click "Create Repository". As soon as the repository is created, GitHub displays a page with a URL and some information on how to configure your local repository.

![](images/clipboard-3105004005.png)

5.  Make sure HTTPS is selected and then click the clipboard icon to copy the URL. We will use this URL in the next section.

Note: you have effectively done the following on GitHub's servers:

```{bash}
$ mkdir planets
$ cd planets
$ git init
```

If you remember back to the earlier episode where we added and committed our earlier work on mars.txt, we had a diagram of the local repository which looked like this:

![](../figures/tracking-changes.png)

Now that we have two repositories, we need a diagram like this

![](../materials/images/git-freshly-made-github-repo.svg)

Note that our local repository still contains our earlier work on `mars.txt`, but the remote repository on GitHub appears empty as it doesn’t contain any files yet.

## **3.2 Connecting to (Cloning) a Remote Repository**

Now we connect the two repositories. We do this by making the GitHub repository a [remote](https://swcarpentry.github.io/git-novice/reference.html#remote) for the local repository. Previously we were shown a page which looked like this:

![](images/clipboard-321009940.png)

At the time, we chose to use HTTPS as our security protocol for connecting the two repositories.

**SAY SOMETHING ABOUT HTTPS vs SSH**

Go into the local `planets` repository, and run this command:

```{bash}
$ git remote add origin https://github.com/<yourusername>/planets.git
```

which is equivalent to

```{bash}
$ git remote add origin <paste copied URL here>
```

`origin` is a local name used to refer to the remote repository. It could be called anything, but `origin` is a convention that is often used by default in git and GitHub, so it’s helpful to stick with this unless there’s a reason not to.

We can check that the command has worked by running `git remote -v`:

```{bash}
$ git remote -v
```

``` bash-output-box
origin   https://github.com/<yourusername>/planets.git (fetch)
origin   https://github.com/<youusername>/planets.git (push)
```

## **3.2 Push Local Changes to a Remote Repository**

Now that authentication is setup, we can return to the remote. This command will push the changes from our local repository to the repository on GitHub:

```{bash}
$ git push origin main
```

``` bash-output-box
Enumerating objects: 16, done.
Counting objects: 100% (16/16), done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.
Total 16 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), done.
To https://github.com/<youusername>/planets.git
 * [new branch]      main -> main
```

![](../materials/images/github-repo-after-first-push.svg)

**ADD SOMETHING about Windows Credential Manager (link to something on the net)**

## **3.3 Ignoring Things**

What if we have files that we do not want Git to track for us, like backup files created by our editor or intermediate files created during data analysis? This often is the case in BC Government data projects

```{bash}
$ mkdir results 
$ touch a.csv b.csv c.csv results/a.out results/b.out
$ git status
```

```{bash}
$ git status
```

``` bash-output-box
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    a.csv
    b.csv
    c.csv
    results/

nothing added to commit but untracked files present (use "git add" to track)
```

Putting these files under version control would be a waste of disk space. Additionally, many BC Stats projects involve data with PI, or other sensitive information, so we generally follow a best practice not to store data in GitHub. We do this by creating a file in the root directory of our project called **.gitignore**:

```{bash}
$ nano .gitignore
$ cat .gitignore
```

``` bash-output-box
*.csv
results/
```

These patterns tell Git to ignore any file whose name ends in .csv and everything in the results directory. (If any of these files were already being tracked, Git would continue to track them.)

Once we have created this file, the output of git status is much cleaner:

```{bash}
$ git status
```

``` bash-output-box
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    .gitignore

nothing added to commit but untracked files present (use "git add" to track)
```

And since everyone we’re sharing our repository with will probably want to ignore the same things that we’re ignoring, let’s add and commit .gitignore:

```{bash}
$ git add .gitignore
$ git commit -m "Ignore data files and the results folder"
```

Now if we try to add our csv files, .gitignore helps us avoid accidentally adding files to the repository that we don’t want to track. It also gives us a way to override the .gitignore using the -f flag.

```{bash}
$ git add a.csv
```

``` bash-output-box
The following paths are ignored by one of your .gitignore files:
a.csv
Use -f if you really want to add them.
```

subdirectories (we don't want ppl pushing data to GitHub)

.gitkeep (time permitting)
