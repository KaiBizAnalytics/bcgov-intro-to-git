[
  {
    "objectID": "slides/01-what-is-vc.html",
    "href": "slides/01-what-is-vc.html",
    "title": "1. What is Version Control",
    "section": "",
    "text": "rnorm(10)\n\n [1]  0.1216613 -2.4947293 -1.0188200  1.0376225  0.3308149 -0.5052030\n [7] -1.3277402  0.2805683  1.4890879 -0.6459442"
  },
  {
    "objectID": "slides/01-what-is-vc.html#heres-some-code-to-copy",
    "href": "slides/01-what-is-vc.html#heres-some-code-to-copy",
    "title": "1. What is Version Control",
    "section": "",
    "text": "rnorm(10)\n\n [1]  0.1216613 -2.4947293 -1.0188200  1.0376225  0.3308149 -0.5052030\n [7] -1.3277402  0.2805683  1.4890879 -0.6459442"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About The Workshop",
    "section": "",
    "text": "This is a 1/2 day workshop introducing participants to version control using git and the popular code hosting platform, GitHub.\nThe goal of this workshop is to teach data professionals how to harness the power of version control by giving attendees a foundation in the fundamentals of version control with git.\nGitHub is a widely-used platform for hosting and sharing code repositories, facilitating seamless collaboration among developers. Git, on the other hand, is a popular version control system that enables you to track changes in your code, collaborate with team members, and maintain a history of your project’s development."
  },
  {
    "objectID": "index.html#introduction-to-version-control-with-git-and-github",
    "href": "index.html#introduction-to-version-control-with-git-and-github",
    "title": "About The Workshop",
    "section": "",
    "text": "This is a 1/2 day workshop introducing participants to version control using git and the popular code hosting platform, GitHub.\nThe goal of this workshop is to teach data professionals how to harness the power of version control by giving attendees a foundation in the fundamentals of version control with git.\nGitHub is a widely-used platform for hosting and sharing code repositories, facilitating seamless collaboration among developers. Git, on the other hand, is a popular version control system that enables you to track changes in your code, collaborate with team members, and maintain a history of your project’s development."
  },
  {
    "objectID": "index.html#learning-outcomes",
    "href": "index.html#learning-outcomes",
    "title": "About The Workshop",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\nBy the end of this course, you will have gained a fundamental understanding of version control, enabling you to:\n\nSet up a GitHub account and install the software git (pre-workshop)\nUnderstand the value-add of using version control to manage software and code-based data science projects\nUnderstand the basics of how automated version control systems work\nUse git, popular command-line version control software, to track local file changes\nWhat are remote hosting platforms and why do we use them?\nConnect to GitHub, create a remote repository and push local changes to GitHub\nBe familiar with the BC Gov Github Organization which has guidelines and requirements for hosting government developed open source repositories.\n\nThe workshop content will follow best practices for version control such as writing descriptive commit messages, including a .gitignore file and tracking relevent project files."
  },
  {
    "objectID": "index.html#who-should-take-this-course",
    "href": "index.html#who-should-take-this-course",
    "title": "About The Workshop",
    "section": "Who should take this course?",
    "text": "Who should take this course?\n\nAnyone looking to solidify their foundational understanding of version control\nAnyone keen to learn what git or GitHub is (no prior experience necessary!)\nAnyone wondering how version control can be used to manage and collaborate on software and code-based data science projects"
  },
  {
    "objectID": "index.html#workshop-schedule",
    "href": "index.html#workshop-schedule",
    "title": "About The Workshop",
    "section": "Workshop Schedule",
    "text": "Workshop Schedule\n\nDaily Schedule (to be finalized)\n\n\n\n\n\n\n\n\nActivity\nStart Time\nEnd Time\n\n\n\n\nSession 1. What is version control?\n8:45\n9:15\n\n\nSession 2. Working locally with git\n9:15\n10:30\n\n\nBREAK ☕\n10:30\n10:45\n\n\nSession 3. Working remotely with GitHub\n10:45\n11:30\n\n\nSession 4. The BC Gov GitHub Organization\n11:30\n12:15\n\n\n\n\n\nPre-Course Work\nImportant!\nBefore the course starts, we ask that all attendees install git and GitBash and have a basic text editor such as Wordpad, Notepad++, or SublimeText. Instructions for how to install these tools are found in the Introduction to git Section. If anyone is having troubles getting the software up and running, please contact us before the course starts so that we can hit the ground running during the workshop."
  },
  {
    "objectID": "course-outline.html",
    "href": "course-outline.html",
    "title": "Course Outline",
    "section": "",
    "text": "Pre-Workshop Installation and Set Up\nLearning Objective: Set up a GitHub account and install git (pre-workshop).\nInstructions: Installation and Set-Up\nAssignment: Pre-Workshop Assignment\n\nTopics/Learning Outcomes:\n\nDownload Git for Windows and bundled software (includes Git Bash) (PC only)\nDownload Git for Mac installer (Mac only)\nCreate a GitHub account with m2FA, PAT for https connection\nConfigure git\nPre-workshop assignment to show local configuration and connection to GitHub\n\nCourse Reference Material:\n\nSW Carpentry Episode 2. Setting Up Git\nbcgov-r-geo-workshop Lesson 1\n\n\n\nSection 1. Introductions and What is Version Control?\nLearning Objective: Understand the value-add of using version control and the the basics of how automated version control systems work.\nSlides: Section 1 Slides\nTopics:\n\nHow version control systems work\nWhat is a repository?\nWhat is the value-add of using version control in teams? individually?\n\nCourse Reference Material:\n\nSW Carpentry Episode 1. Automated Version Control\n\n\n\nSection 2. Working local with git\nLearning Objective: Use command-line git to track local file changes.\nSlides: Section 2 Slides\nTopics:\n\nDefault branch naming (inclusive language)\nWhat is Bash\nBash-specific commands: mkdir, rm -r, cd, ls\nGit Bash commands: init, commit, add, status, log\nDirectory structure\nTracking changes made to a text doc\nWhat to do when when -m is omitted.\n\nCourse Reference Material:\n\nSW Carpentry Episode 3. Creating a Repository (Local)\nSW Carpentry Episode 4. Tracking Changes\nbcgov-r-geo-workshop Lesson 2\nbcgov-r-geo-workshop Lesson 3\nbcgov-r-geo-workshop Lesson 5\n\n\n\nSection 3. Remote Code Hosting and GitHub\nLearning Objective: What are remote hosting platforms and why do we use them?\nSlides: Section 3 Slides\nTopics:\n\nMore on secure authentication/login: username/password/2FA to sign in to account, PAT to authenticate\nGit Bash commands: push, pull\nCreate a remote repository\nClone a remote repostitory\nPush local changes to GitHub.\n.gitgnore and subdirectories (we don’t want ppl pushing data to GitHub)\n.gitkeep (time permitting)\n\nCourse Reference Material:\n\nSW Carpentry Episode 6. Ignoring Things\nSW Carpentry Episode 7. Remotes in GitHub\nbcgov-r-geo-workshop Lesson 6\nGithub: Keeping your Account and Data Secure\n\n\n\nSection 4. BC Government GitHub Organization (bcgov)\nLearning Objective: Understand how the bcgov framework, policy and related tools help B.C. government employees share code on GitHub\nSlides: Section 4 Slides\nTopics:\n\nwhat is the bcgov organization framework\nbcgov policy framework and licensing\ncode-sharing and teams\nbcgov-c, bcgov enterprise\n\nCourse Reference Material:\n\nSW Carpentry Episode 10. Open Science\nSW Carpentry Episode 11. Licensing\nSW Carpentry Episode 12. Citation\nSW Carpentry Episode 13. Hosting\n\nFurther Links to bcgov Organization Resources:\n\nContent Approval Checklist\nBC Gov Organizations in GitHub\nPolicy Framework",
    "crumbs": [
      "About The Workshop",
      "Getting Started",
      "Course Outline"
    ]
  },
  {
    "objectID": "materials/02-working-local.html",
    "href": "materials/02-working-local.html",
    "title": "2. Working Locally with Git",
    "section": "",
    "text": "First, let’s create a new directory on the C drive for our work. Your user profile on the C drive is the best place to create a repository for now. Git does not know how to reconcile ownership H drive as a “safe” place for our work. After changing to the C: drive, and creating a new directory, we will change the current working directory to the newly created one:\n\n$ cd c:/Users/BASHCROF\n$ mkdir planets\n$ cd planets\n\nThen we tell Git to make planets a repository – a place where Git can store versions of our files:\n\n$ git init\n\nIt is important to note that git init will create a repository that can include subdirectories and their files—there is no need to create separate repositories nested within the planets repository, whether subdirectories are present from the beginning or added later. Also, note that the creation of the planets directory and its initialization as a repository are completely separate processes.\nIf we use ls to show the directory’s contents, it appears that nothing has changed:\n\n$ ls\n\nBut if we add the -a flag to show everything, we can see that Git has created a hidden directory within planets called .git:\n\n$ ls -a\n\nWe get the following output:\n.   ..  .git\nGit uses this special subdirectory to store all the information about the project, including the tracked files and sub-directories located within the project’s directory. If we ever delete the .gitsubdirectory, we will lose the project’s history.\nNext, we will change the default branch to be called main. This might be the default branch depending on your settings and version of git. See the setup episode for more information on this change.\n\n$ git checkout -b main\n\nWe get the following output:\nSwitched to a new branch 'main'\nWe can check that everything is set up correctly by asking Git to tell us the status of our project:\n\n$ git status\n\nWe get the following output:\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\nIf you are using a different version of git, the exact wording of the output might be slightly different.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#creating-a-repository",
    "href": "materials/02-working-local.html#creating-a-repository",
    "title": "2. Working Locally with Git",
    "section": "",
    "text": "First, let’s create a new directory on the C drive for our work. Your user profile on the C drive is the best place to create a repository for now. Git does not know how to reconcile ownership H drive as a “safe” place for our work. After changing to the C: drive, and creating a new directory, we will change the current working directory to the newly created one:\n\n$ cd c:/Users/BASHCROF\n$ mkdir planets\n$ cd planets\n\nThen we tell Git to make planets a repository – a place where Git can store versions of our files:\n\n$ git init\n\nIt is important to note that git init will create a repository that can include subdirectories and their files—there is no need to create separate repositories nested within the planets repository, whether subdirectories are present from the beginning or added later. Also, note that the creation of the planets directory and its initialization as a repository are completely separate processes.\nIf we use ls to show the directory’s contents, it appears that nothing has changed:\n\n$ ls\n\nBut if we add the -a flag to show everything, we can see that Git has created a hidden directory within planets called .git:\n\n$ ls -a\n\nWe get the following output:\n.   ..  .git\nGit uses this special subdirectory to store all the information about the project, including the tracked files and sub-directories located within the project’s directory. If we ever delete the .gitsubdirectory, we will lose the project’s history.\nNext, we will change the default branch to be called main. This might be the default branch depending on your settings and version of git. See the setup episode for more information on this change.\n\n$ git checkout -b main\n\nWe get the following output:\nSwitched to a new branch 'main'\nWe can check that everything is set up correctly by asking Git to tell us the status of our project:\n\n$ git status\n\nWe get the following output:\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\nIf you are using a different version of git, the exact wording of the output might be slightly different.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#tracking-files",
    "href": "materials/02-working-local.html#tracking-files",
    "title": "2. Working Locally with Git",
    "section": "2.2 Tracking Files",
    "text": "2.2 Tracking Files\nFirst let’s make sure we’re still in the right directory. You should be in the planets directory.\n\n$ cd ~/Desktop/planets\n\nLet’s create a file called mars.txt that contains some notes about the Red Planet’s suitability as a base. Open a new document named mars.txt using a plain text editor such as Notepad++. Add the following line to mars.txt and save the file.\nCold and dry, but everything is my favorite color\nAfter switching back to the GitBash command-line interface, let’s verify that the file was properly created by running the list command (ls):\n\n$ ls\n\nWe should see the following file in our directory:\nmars.txt\nIf we check the status of our project again, Git tells us that it’s noticed the new file:\n\n$ git status\n\nOn branch main\n\nNo commits yet\n\nUntracked files:\n   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    mars.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nThe “untracked files” message means that there’s a file in the directory that Git isn’t keeping track of. We can tell Git to track a file using git add:\n\n$ git add mars.txt\n\nand then check that the right thing happened:\n\n$ git status\n\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n\n    new file:   mars.txt",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#committing-changes",
    "href": "materials/02-working-local.html#committing-changes",
    "title": "2. Working Locally with Git",
    "section": "2.3 Committing Changes",
    "text": "2.3 Committing Changes\nGit now knows that it’s supposed to keep track of mars.txt, but it hasn’t recorded these changes as a commit yet. To get it to do that, we need to run one more command:\n\n$ git commit -m \"Start notes on Mars as a base\"\n\n[main (root-commit) f22b25e] Start notes on Mars as a base\n 1 file changed, 1 insertion(+)\n create mode 100644 mars.txt\nWhen we run git commit, Git takes everything we have told it to save by using git add and stores a copy permanently inside the special .git directory. This permanent copy is called a commit (or revision) and its short identifier is f22b25e. Your commit may have another identifier.\nWe use the -m flag (for “message”) to record a short, descriptive, and specific comment that will help us remember later on what we did and why.\n\n\n\n\n\n\nNote\n\n\n\nIf we just run git commit without the -m option, Git will launch a utility program called nano  and ask us to write a longer message. If this happens, click CTRL+X to go back to the command line and run git commit -m \"your commit message\".\n\n\n\n\n\n\n\n\nNote\n\n\n\nGood commit messages start with a brief (&lt;50 characters) statement about the changes made in the commit. Generally, the message should complete the sentence “If applied, this commit will” . If you want to go into more detail, add a blank line between the summary line and your additional notes. Use this additional space to explain why you made changes and/or what their impact will be.\n\n\nIf we run git status now:\n\n$ git status\n\nOn branch main\nnothing to commit, working tree clean\nit tells us everything is up to date.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#viewing-the-commit-history",
    "href": "materials/02-working-local.html#viewing-the-commit-history",
    "title": "2. Working Locally with Git",
    "section": "2.4 Viewing the Commit History",
    "text": "2.4 Viewing the Commit History\nIf we want to know what we’ve done recently, we can ask Git to show us the project’s history using git log:\n\n$ git log\n\ncommit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    Start notes on Mars as a base\ngit log lists all commits made to a repository in reverse chronological order. The listing for each commit includes the commit’s full identifier (which starts with the same characters as the short identifier printed by the git commit command earlier), the commit’s author, when it was created, and the log message Git was given when the commit was created.\nLet’s add more information to the file. Again, open up your text editor to add and save your changes. Switch back to command line when you’re finished.\nmars.txt contains a new line, which we can verify by running:\n\n$ cat mars.txt\n\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nWhen we run git status now, it tells us that a file it already knows about has been modified:\n\n$ git status\n\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n    modified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nThe last line is the key phrase: “no changes added to commit”. We have changed this file, but we haven’t told Git we will want to save those changes (which we do with git add) nor have we saved them (which we do with git commit).\nAfter reviewing our change, it’s time to commit it:\n\n$ git add mars.txt\n$ git commit -m \"Add concerns about effects of Mars' moons on Wolfman\"\n\n[main 34961b1] Add concerns about effects of Mars' moons on Wolfman\n 1 file changed, 1 insertion(+)\nGit insists that we add files to the set we want to commit before actually committing anything. This allows us to commit our changes in stages and capture changes in logical portions rather than only large batches. For example, suppose we’re adding a few citations to relevant research to our thesis. We might want to commit those additions, and the corresponding bibliography entries, but not commit some of our work drafting the conclusion (which we haven’t finished yet).",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#the-staging-area",
    "href": "materials/02-working-local.html#the-staging-area",
    "title": "2. Working Locally with Git",
    "section": "2.5 The Staging Area",
    "text": "2.5 The Staging Area\nTo allow for this, Git has a special staging area where it keeps track of things that have been added to the current changeset but not yet committed.\nIf you think of Git as taking snapshots of changes over the life of a project, git add specifies what will go in a snapshot (putting things in the staging area), and git commit then actually takes the snapshot, and makes a permanent record of it (as a commit). If you don’t have anything staged when you type git commit, Git will prompt you to use git commit -a or git commit –all, which is kind of like gathering everyone to take a group photo! However, it’s almost always better to explicitly add things to the staging area, because you might commit changes you forgot you made. (Going back to the group photo simile, you might get an extra with incomplete makeup walking on the stage for the picture because you used -a!) Try to stage things manually, or you might find yourself searching for “git undo commit” more than you would like!\n\n\n\nThe Git Staging Area",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "pre-workshop/assignment.html",
    "href": "pre-workshop/assignment.html",
    "title": "Pre-Workshop Assignment",
    "section": "",
    "text": "To make the most of our time together on the day of the workshop, we would like you to show up ready-to-go with the proper software installed and configured correctly on your local machine. After working through the installation instructions, please include the following in a single Word or PDF document.\n\n\nOpen the application Git Bash on your local computer and enter the following commands at the command prompt.\n$ git config -–list\nTake a screen shot of the command-line output.\n\n\n\nYou can find this by signing in to GitHub and clicking on your avatar at the top right. Your GitHub handle is in bold font above your name."
  },
  {
    "objectID": "pre-workshop/assignment.html#pre-workshop-assignment",
    "href": "pre-workshop/assignment.html#pre-workshop-assignment",
    "title": "Pre-Workshop Assignment",
    "section": "",
    "text": "To make the most of our time together on the day of the workshop, we would like you to show up ready-to-go with the proper software installed and configured correctly on your local machine. After working through the installation instructions, please include the following in a single Word or PDF document.\n\n\nOpen the application Git Bash on your local computer and enter the following commands at the command prompt.\n$ git config -–list\nTake a screen shot of the command-line output.\n\n\n\nYou can find this by signing in to GitHub and clicking on your avatar at the top right. Your GitHub handle is in bold font above your name."
  },
  {
    "objectID": "pre-workshop/software-install.html",
    "href": "pre-workshop/software-install.html",
    "title": "Installion Instructions and Set-Up",
    "section": "",
    "text": "As part of this workshop we will be connecting and pushing some sample code to GitHub, therefore you’ll need to create a GitHub account. In general, creating a GitHub account can be a great way to collaborate on open-source projects, showcase your work, and learn from others.\n\nGo to https://github.com and click “Sign up” at the top-right of the window.\nFollow the step-by-step instructions to create an account.\nVerify your email address with GitHub.\n\nOptional reading: Configuring your GitHub account\n\n\n\nWhen we sign in to GitHub on the web, we are signing into our application account created in step 1. This is where we manage our profile settings, set our passwords, and browse repositories. It is possible to edit repository content from GitHub although editing is typically performed in a local application such as RStudio, VS Code or a text editor. We will go into more detail on that in the course workshop.\n\nGo to https://github.com/ and click “Sign In” (top right corner).\n\nEnter either your username or your email address, and password created in Step 1.\n\n\n\n\nAs of 2023 all GitHub accounts are required to have multi-factor authentication (2FA) configured for extra security. Several options exist for setting up 2FA, the simplest is via text message described below.\n\nIn the upper-right corner of any page, click on your profile photo and select Settings.\nIn the “Access” section of the sidebar, click on Password and authentication.\nScroll down to “Two-factor authentication” section of the page and click Enable two-factor authentication.\nAt the bottom of the page, next to “SMS authentication”, click Select.\nComplete the CAPTCHA challenge, which helps protect against spam and abuse.\nUnder “Setup SMS authentication”, select your country code and type your mobile phone number, including the area code. When your information is correct, click Send authentication code.\nYou’ll receive a text message with a security code. On GitHub, type the code into the field under “Verify the code sent to your phone” and click Continue.\nIf you need to edit the phone number you entered, you’ll need to complete another CAPTCHA challenge.\nUnder “Save your recovery codes”, click Download to download your two-factor recovery codes to your device. Save them to a secure location because your recovery codes can help you get back into your account if you lose access.\nAfter saving your two-factor recovery codes, click “I have saved my recovery codes” to enable two-factor authentication for your account.\n\nOptional reading: Other 2FA configurations.\n\n\n\nTo keep your account secure, you must authenticate before you can access certain resources on GitHub. When we access resources via a browser (as in Step 2) we are authenticating with our username and password and two-factor authentication. In the workshop we will also be accessing GitHub resources via the REST API. You can authenticate with the API in different ways, but the simplest way is with a Classic Personal Access Token (PAT).\nFirst verify your email address (if it hasn’t been verified yet):\n\nIn the upper-right corner of any page, click your profile photo, then click Settings.\nIn the “Access” section of the sidebar, click Emails.\nUnder your email address, click Resend verification email.\nGitHub will send you an email with a link in it. After you click that link, you’ll be taken to your GitHub dashboard and see a confirmation banner.\n\nThen create your PAT:\n\nIn the upper-right corner of any page, click your profile photo, then click Settings.\nIn the left sidebar, click Developer settings.\nIn the left sidebar, under Personal access tokens, click Tokens (classic).\nSelect Generate new token, then click Generate new token (classic).\nIn the “Note” field, give your token a descriptive name. At some point you may use a second PAT and a name helps keep things straight but for now you could name it “work-2023” or “november-2023”.\nTo give your token an expiration date, select Expiration. For first time users, 30 days is a good choice, after which time GitHub will send an email notification reminding you to renew your PAT.\nSelect the scopes you’d like to grant this token. The repo and user boxes should be sufficient for the workshop and most cases in general.\nClick Generate token.\nCopy the new token to your clipboard and save to a text file for later.\n\nOptional reading: Authenticating to the REST API\n\n\n\nGit is a set of command line utility programs that are designed to execute on a Unix style command-line environment. Linux and macOS both include built-in Unix command line terminals. Most likely you are working on a Windows operating system and will require Git Bash, an application for Windows environments which provides an emulation layer for a Git command line experience.\n\n\n\nSearch for “Git Bash” in your start menu to see if Git/GitBash are installed on your computer already.\n\nIf not, navigate to Git for Windows and click “Download” to download Git/GitBash bundled software.\nWhen you’ve successfully started the installer, you should see the Git Setup wizard screen. Follow the Next and Finish prompts to complete the installation. The default options are pretty sensible for most users.\n\n\n\n\nPlease visit: Installing Git and follow the instructions for installing git for MacOSX.\n\n\n\n\n\n\nWhen we use Git on a new computer for the first time, we need to configure a few things. Below are a few examples of configurations we will set as we get started with Git:\n\nour name and email address\nand that we want to use these settings globally (i.e. for every project).\n\nOn a command line, Git commands are written as git verb options, where verb is what we actually want to do and options is additional optional information which may be needed for the verb.\n\n\n\nIn our workshop, we will be interacting with GitHub and so our configured email address should be the same as the one used when setting up your GitHub account. Most likely this will be your governement email.\nBelow is an example configuration, please type in the commands using your name and email address.\n$ git config --global user.name \"Your Name in Quotes\"\n$ git config --global user.email \"your_email@gmail.com\"\nIf you are concerned about privacy, please review GitHub’s instructions for keeping your email address private.\n\n\n\nThe two commands we just ran above only need to be run once: the flag --global tells Git to use the settings for every project, in your user account, on this computer.\nYou can check your settings at any time:\n$ git config --list\nYou can change your configuration as many times as you want: use the same commands to update your name or email address.\n\n\n\nAlways remember that if you forget a git command, you can access the list of commands by using -h and access the Git manual by using --help :\n$ git config -h\n$ git config --help\nWhile viewing the manual, remember the : is a prompt waiting for commands and you can press Q to exit the manual."
  },
  {
    "objectID": "pre-workshop/software-install.html#getting-started-with-github",
    "href": "pre-workshop/software-install.html#getting-started-with-github",
    "title": "Installion Instructions and Set-Up",
    "section": "",
    "text": "As part of this workshop we will be connecting and pushing some sample code to GitHub, therefore you’ll need to create a GitHub account. In general, creating a GitHub account can be a great way to collaborate on open-source projects, showcase your work, and learn from others.\n\nGo to https://github.com and click “Sign up” at the top-right of the window.\nFollow the step-by-step instructions to create an account.\nVerify your email address with GitHub.\n\nOptional reading: Configuring your GitHub account\n\n\n\nWhen we sign in to GitHub on the web, we are signing into our application account created in step 1. This is where we manage our profile settings, set our passwords, and browse repositories. It is possible to edit repository content from GitHub although editing is typically performed in a local application such as RStudio, VS Code or a text editor. We will go into more detail on that in the course workshop.\n\nGo to https://github.com/ and click “Sign In” (top right corner).\n\nEnter either your username or your email address, and password created in Step 1.\n\n\n\n\nAs of 2023 all GitHub accounts are required to have multi-factor authentication (2FA) configured for extra security. Several options exist for setting up 2FA, the simplest is via text message described below.\n\nIn the upper-right corner of any page, click on your profile photo and select Settings.\nIn the “Access” section of the sidebar, click on Password and authentication.\nScroll down to “Two-factor authentication” section of the page and click Enable two-factor authentication.\nAt the bottom of the page, next to “SMS authentication”, click Select.\nComplete the CAPTCHA challenge, which helps protect against spam and abuse.\nUnder “Setup SMS authentication”, select your country code and type your mobile phone number, including the area code. When your information is correct, click Send authentication code.\nYou’ll receive a text message with a security code. On GitHub, type the code into the field under “Verify the code sent to your phone” and click Continue.\nIf you need to edit the phone number you entered, you’ll need to complete another CAPTCHA challenge.\nUnder “Save your recovery codes”, click Download to download your two-factor recovery codes to your device. Save them to a secure location because your recovery codes can help you get back into your account if you lose access.\nAfter saving your two-factor recovery codes, click “I have saved my recovery codes” to enable two-factor authentication for your account.\n\nOptional reading: Other 2FA configurations.\n\n\n\nTo keep your account secure, you must authenticate before you can access certain resources on GitHub. When we access resources via a browser (as in Step 2) we are authenticating with our username and password and two-factor authentication. In the workshop we will also be accessing GitHub resources via the REST API. You can authenticate with the API in different ways, but the simplest way is with a Classic Personal Access Token (PAT).\nFirst verify your email address (if it hasn’t been verified yet):\n\nIn the upper-right corner of any page, click your profile photo, then click Settings.\nIn the “Access” section of the sidebar, click Emails.\nUnder your email address, click Resend verification email.\nGitHub will send you an email with a link in it. After you click that link, you’ll be taken to your GitHub dashboard and see a confirmation banner.\n\nThen create your PAT:\n\nIn the upper-right corner of any page, click your profile photo, then click Settings.\nIn the left sidebar, click Developer settings.\nIn the left sidebar, under Personal access tokens, click Tokens (classic).\nSelect Generate new token, then click Generate new token (classic).\nIn the “Note” field, give your token a descriptive name. At some point you may use a second PAT and a name helps keep things straight but for now you could name it “work-2023” or “november-2023”.\nTo give your token an expiration date, select Expiration. For first time users, 30 days is a good choice, after which time GitHub will send an email notification reminding you to renew your PAT.\nSelect the scopes you’d like to grant this token. The repo and user boxes should be sufficient for the workshop and most cases in general.\nClick Generate token.\nCopy the new token to your clipboard and save to a text file for later.\n\nOptional reading: Authenticating to the REST API\n\n\n\nGit is a set of command line utility programs that are designed to execute on a Unix style command-line environment. Linux and macOS both include built-in Unix command line terminals. Most likely you are working on a Windows operating system and will require Git Bash, an application for Windows environments which provides an emulation layer for a Git command line experience.\n\n\n\nSearch for “Git Bash” in your start menu to see if Git/GitBash are installed on your computer already.\n\nIf not, navigate to Git for Windows and click “Download” to download Git/GitBash bundled software.\nWhen you’ve successfully started the installer, you should see the Git Setup wizard screen. Follow the Next and Finish prompts to complete the installation. The default options are pretty sensible for most users.\n\n\n\n\nPlease visit: Installing Git and follow the instructions for installing git for MacOSX.\n\n\n\n\n\n\nWhen we use Git on a new computer for the first time, we need to configure a few things. Below are a few examples of configurations we will set as we get started with Git:\n\nour name and email address\nand that we want to use these settings globally (i.e. for every project).\n\nOn a command line, Git commands are written as git verb options, where verb is what we actually want to do and options is additional optional information which may be needed for the verb.\n\n\n\nIn our workshop, we will be interacting with GitHub and so our configured email address should be the same as the one used when setting up your GitHub account. Most likely this will be your governement email.\nBelow is an example configuration, please type in the commands using your name and email address.\n$ git config --global user.name \"Your Name in Quotes\"\n$ git config --global user.email \"your_email@gmail.com\"\nIf you are concerned about privacy, please review GitHub’s instructions for keeping your email address private.\n\n\n\nThe two commands we just ran above only need to be run once: the flag --global tells Git to use the settings for every project, in your user account, on this computer.\nYou can check your settings at any time:\n$ git config --list\nYou can change your configuration as many times as you want: use the same commands to update your name or email address.\n\n\n\nAlways remember that if you forget a git command, you can access the list of commands by using -h and access the Git manual by using --help :\n$ git config -h\n$ git config --help\nWhile viewing the manual, remember the : is a prompt waiting for commands and you can press Q to exit the manual."
  },
  {
    "objectID": "pre-workshop/software-install.html#additional-resources",
    "href": "pre-workshop/software-install.html#additional-resources",
    "title": "Installion Instructions and Set-Up",
    "section": "Additional Resources",
    "text": "Additional Resources\nhttps://github.com/bcgov/BC-Policy-Framework-For-GitHub. Get added to the BC Government GitHub Org (“BCGov”) https://just-ask.developer.gov.bc.ca/"
  },
  {
    "objectID": "CODE_OF_CONDUCT.html",
    "href": "CODE_OF_CONDUCT.html",
    "title": "Contributor Code of Conduct",
    "section": "",
    "text": "Contributor Code of Conduct\nAs contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.\nWe are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.\nExamples of unacceptable behavior by participants include:\n\nThe use of sexualized language or imagery\nPersonal attacks\nTrolling or insulting/derogatory comments\nPublic or private harassment\nPublishing other’s private information, such as physical or electronic addresses, without explicit permission\nOther unethical or unprofessional conduct\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\nBy adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting a project maintainer at bonnie.robert@gov.bc.ca or lindsay.forestall@gov.bc.ca. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident.\nThis Code of Conduct is adapted from the Contributor Covenant, version 1.3.0, available at http://contributor-covenant.org/version/1/3/0/\n\nThis project was created using the bcgovr package."
  },
  {
    "objectID": "materials/01-what-is-vc.html",
    "href": "materials/01-what-is-vc.html",
    "title": "1. What is Version Control",
    "section": "",
    "text": "Version control, also known as source control, is the practice of tracking and managing changes to software code. Version control systems are software tools that are used to help individuals and software development teams manage changes to code/documents over time.\nConsider the following scenario. You and your colleagues have been asked to do an analysis of the Work Environment Survey study to determine if workplace satisfaction has increased or decreased significantly since the start of the pandemic. You and your colleagues want to be able to work on the project at the same time, but have run into problems doing this in the past. If you take turns, each of you will spend a lot of time waiting for the other to finish, but if you work on your own copies and save them to the local network, things will be lost, overwritten, or duplicated. A colleague suggests using version control to manage your work.\nWe’ve all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document. Some word processors let us deal with this a little better, such as Microsoft Word’s Track Changes and Google Docs’ version history.\nVersion control systems start with a base version of the document and then record changes you make each step of the way. You can think of it as a recording of your progress: you can rewind to start at the base document and play back each change you made, eventually arriving at your more recent version.\n\n\n\nChanges Are Saved Sequentially\n\n\nOnce you think of changes as separate from the document itself, you can then think about “playing back” different sets of changes on the base document, ultimately resulting in different versions of that document. For example, two users can make independent sets of changes on the same document.\n\n\n\nDifferent Versions Can be Saved and Merged\n\n\nUnless multiple users make changes to the same section of the document - a conflict - you can incorporate two sets of changes into the same base document.\nA version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files. It allows us to decide which changes will be made to the next version (each record of these changes is called a commit), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a repository. Repositories can be kept in sync across different computers, facilitating collaboration among different people.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "1. What is Version Control"
    ]
  },
  {
    "objectID": "materials/01-what-is-vc.html#what-is-version-control",
    "href": "materials/01-what-is-vc.html#what-is-version-control",
    "title": "1. What is Version Control",
    "section": "",
    "text": "Version control, also known as source control, is the practice of tracking and managing changes to software code. Version control systems are software tools that are used to help individuals and software development teams manage changes to code/documents over time.\nConsider the following scenario. You and your colleagues have been asked to do an analysis of the Work Environment Survey study to determine if workplace satisfaction has increased or decreased significantly since the start of the pandemic. You and your colleagues want to be able to work on the project at the same time, but have run into problems doing this in the past. If you take turns, each of you will spend a lot of time waiting for the other to finish, but if you work on your own copies and save them to the local network, things will be lost, overwritten, or duplicated. A colleague suggests using version control to manage your work.\nWe’ve all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document. Some word processors let us deal with this a little better, such as Microsoft Word’s Track Changes and Google Docs’ version history.\nVersion control systems start with a base version of the document and then record changes you make each step of the way. You can think of it as a recording of your progress: you can rewind to start at the base document and play back each change you made, eventually arriving at your more recent version.\n\n\n\nChanges Are Saved Sequentially\n\n\nOnce you think of changes as separate from the document itself, you can then think about “playing back” different sets of changes on the base document, ultimately resulting in different versions of that document. For example, two users can make independent sets of changes on the same document.\n\n\n\nDifferent Versions Can be Saved and Merged\n\n\nUnless multiple users make changes to the same section of the document - a conflict - you can incorporate two sets of changes into the same base document.\nA version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files. It allows us to decide which changes will be made to the next version (each record of these changes is called a commit), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a repository. Repositories can be kept in sync across different computers, facilitating collaboration among different people.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "1. What is Version Control"
    ]
  },
  {
    "objectID": "materials/01-what-is-vc.html#why-version-control",
    "href": "materials/01-what-is-vc.html#why-version-control",
    "title": "1. What is Version Control",
    "section": "1.2 Why Version Control?",
    "text": "1.2 Why Version Control?\nVersion control is the lab notebook of the digital world: it’s what professionals use to keep track of what they’ve done and to collaborate with other people.\nVersion control is better than sharing files back and forth because:\n\nNothing that is committed to version control is ever lost, unless you work really, really hard at it. Since all old versions of files are saved, it’s always possible to go back in time to see exactly who wrote what on a particular day, or what version of a program was used to generate a particular set of results.\nAs we have this record of who made what changes when, we know who to ask if we have questions later on, and, if needed, revert to a previous version, much like the “undo” feature in an editor.\nWhen several people collaborate in the same project, it’s possible to accidentally overlook or overwrite someone’s changes. The version control system automatically notifies users whenever there’s a conflict between one person’s work and another’s.\n\n\n\n\n\n\n\nNote\n\n\n\nTeams are not the only ones to benefit from version control: lone researchers can benefit immensely. Keeping a record of what was changed, when, and why is extremely useful for all researchers if they ever need to come back to the project later on (e.g., a year later, when memory has faded).",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "1. What is Version Control"
    ]
  },
  {
    "objectID": "materials/01-what-is-vc.html#what-is-a-version-control-repository",
    "href": "materials/01-what-is-vc.html#what-is-a-version-control-repository",
    "title": "1. What is Version Control",
    "section": "1.3 What is a Version Control Repository?",
    "text": "1.3 What is a Version Control Repository?\nIn version control systems, a repository is a data structure that stores metadata for a set of files or directory structure. Some of the metadata that a repository contains includes, among other things, a historical record of changes in the repository, a set of commit objects, and a set of references to commit objects, called heads.\nEssentially, a version control repository keeps track of a set of files in a project. It is like a regular project folder containing sub folders to organize your work, but with an additional .git folder in which to house metadata. We will go into more detail on how the .git folder and metadata files are created during the workshop.\nUsing the WES analysis example above, you and your colleagues may choose to structure your version control project like this:\n├──wes-analysis\n|  ├── data\n|  │   ├── wes-results\n|  │   │   ├── wes-results-2019.csv\n|  │   │   ├── wes-results-2020.csv\n|  │   │   ├── wes-results-2021.csv\n|  │   |   |── wes-results-2022.csv\n|  ├── doc\n|  ├── ref\n|  │   ├── references\n|  │   ├── images\n|  ├── plots\n|  ├── code\n|  ├── .git",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "1. What is Version Control"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html",
    "href": "materials/03-remote-hosting.html",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "",
    "text": "Version control really comes into its own when we begin to collaborate with other people. We already have most of the machinery we need to do this; the only thing missing is to copy changes from one repository to another.\nSystems like Git allow us to move work between two repositories. The repositories can live on separate computers or network locations. In practice, we often use one copy as a central hub, and keep it on the web rather than on someone’s laptop. Most programmers use a hosting service like GitHub to hold the central repositories; and this is true for many BC Government employees.\nIf you recall, in the pre-workshop, you created a GitHub account and associated it with your GitHub handle (or ID). You also configured your computer with a token (PAT) in a way that should seamlessly allow us to to create a remote repository on GitHub that will be linked to our local repository. Then we will share the changes we’ve made to our current project with the world.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#creating-a-remote-repository",
    "href": "materials/03-remote-hosting.html#creating-a-remote-repository",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "3.1 Creating a Remote Repository",
    "text": "3.1 Creating a Remote Repository\n\nLog in to GitHub. Your personal dashboard is the first page you’ll see when you sign in on GitHub.\nTip: To access your personal dashboard once you’re signed in, click the invertocat  logo in the upper-left corner of any page on GitHub.\nClick on the + icon in the top right corner of your personal dashboard, then New Repository\nName your repository “planets”. Further down the page are other options available to us that can be toggled to suit the repository’s purpose. For this workshop it’s fine to create a “Public” repository. However, as this repository will be connected to a local repository, it needs to be empty. Therefore, leave “Add a README file” unchecked, and select “None” as options for both “Add .gitignore” and “Add a license.”\nClick “Create Repository”. As soon as the repository is created, GitHub displays a page with a URL and some information on how to configure your local repository.\n\n\n\nMake sure HTTPS is selected and then click the clipboard icon to copy the URL. We will use this URL in the next section.\n\nYou have effectively done the following on GitHub’s servers:\n\n$ mkdir planets\n$ cd planets\n$ git init\n\n\n\n\n\n\n\nHTTPS vs SSH - what’s the difference?\n\n\n\nHTTP and SSH refer to different protocols Git can use to transfer data. SSH is ubiquitous; many network admins have experience with them and many OS distributions are set up with them or have tools to manage them. Access over SSH is secure as all data transfer is encrypted and authenticated. It is also efficient, making the data as compact as possible before transferring it.\nHTTP operates very similarly to the SSH protocol but runs over standard HTTPS ports and can use various HTTP authentication mechanisms, meaning it’s often easier on the user than something like SSH, since you can use things like username/password authentication rather than having to set up SSH keys.\n\n\nIf you remember back to the earlier episode where we added and committed our earlier work on mars.txt, we had a diagram of the local repository which looked like this:\n\nNow that we have two repositories, we need a diagram like this\n\n\n\n\n\n\n\nNote\n\n\n\nOur local repository still contains our earlier work on mars.txt, but the remote repository on GitHub appears empty as it doesn’t contain any files yet.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#connecting-to-cloning-a-remote-repository",
    "href": "materials/03-remote-hosting.html#connecting-to-cloning-a-remote-repository",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "3.2 Connecting to (Cloning) a Remote Repository",
    "text": "3.2 Connecting to (Cloning) a Remote Repository\nNow we connect the two repositories. We do this by making the GitHub repository a remote for the local repository. Remote branches are configured using the git remote command.\nGo into the local planets repository, and run this command (using the URL copied to our clipboard):\n\n$ git remote add origin &lt;paste copied URL here&gt;\n\nalternatively,\n\n$ git remote add origin https://github.com/&lt;yourusername&gt;/planets.git\n\n\n\n\n\n\n\nNote\n\n\n\n“origin” is a local name used to refer to the remote repository. It could be called anything, but “origin” is a convention that is often used by default in git and GitHub, so it’s helpful to stick with this unless there’s a reason not to.\n\n\nWe can check that the command has worked by running git remote -v:\n\n$ git remote -v\n\norigin   https://github.com/&lt;yourusername&gt;/planets.git (fetch)\norigin   https://github.com/&lt;youusername&gt;/planets.git (push)",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#push-local-changes-to-a-remote-repository",
    "href": "materials/03-remote-hosting.html#push-local-changes-to-a-remote-repository",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "3.2 Push Local Changes to a Remote Repository",
    "text": "3.2 Push Local Changes to a Remote Repository\nNow that authentication is setup, we can return to the remote. The git push command is used to upload local repository content to a remote repository. This command is how you transfer commits from your local repository to the repository on GitHub.\n\n$ git push origin main\n\nEnumerating objects: 16, done.\nCounting objects: 100% (16/16), done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (11/11), done.\nWriting objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.\nTotal 16 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/&lt;youusername&gt;/planets.git\n * [new branch]      main -&gt; main\nThe git push command takes two arguments: the name of the remote repository and an optional branch name. Used without the branch name (git push origin) will push changes from all local branches to the remote. We may also use git push without specifying any arguments if we’ve already configured the remote for the current branch. Git push will push only changes on our current branch to the remote.\nNow our repositories look like:",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#ignoring-things",
    "href": "materials/03-remote-hosting.html#ignoring-things",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "3.3 Ignoring Things",
    "text": "3.3 Ignoring Things\nWhat if we have files that we do not want Git to track for us, like backup files created by our editor or intermediate files created during data analysis? This often is the case in BC Government data projects.\nLet’s create a file called a.csv that contains some data about the Red Planet’s average temperature. Open a new csv using Excel and add two columns named ‘Time’ and ‘Temperature’. Add a few rows of data if you want and save it to the planets directory. Then check the output of git status.\n\n$ git status\n\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    a.csv\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nPutting data files under version control can be a waste of disk space and may put privacy at risk. As many BC Stats projects involve data with PI or other sensitive information, we generally follow a best practice of not pushing data to GitHub. We accomplish this by creating a file in the root directory of our project called a .gitignore.\nAgain, open up your favorite text editor and type the following line into the first line of the file:\n*.csv\nThen save and close the file, naming it .gitignore. Don’t forget the dot at the beginning!\nThese patterns tell Git to ignore any file whose name ends in .csv and everything in the results directory. (If any of these files were already being tracked, Git would continue to track them.)\nOnce we have created this file, the output of git status is much cleaner:\n\n$ git status\n\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    .gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nAnd since everyone we’re sharing our repository with will probably want to ignore the same things that we’re ignoring, let’s add and commit our .gitignore:\n\n$ git add .gitignore\n$ git commit -m \"Ignore data file\"\n\nNow if we try to add our csv files, .gitignore helps us avoid accidentally adding files to the repository that we don’t want to track. It also gives us a way to override the .gitignore with the -f flag.\n\n$ git add a.csv\n\nThe following paths are ignored by one of your .gitignore files:\na.csv\nUse -f if you really want to add them.\nGo ahead and push your .gitignore to the remote so other people working on our project can use it too.\n\n$ git push\n\nWe can also ignore full subfolders by adding the folder name to our .gitignore.\nAdd another line to your .gitignore so it looks like:\n*.csv\nresults/\nMake a subfolder in planets:\n\n$ mkdir results\n\nAnd then add a .txt file to that subfolder. Again, open up your favorite text editor and add some text to a file and save your changes. Switch back to command line when you’re finished and check the git status.\n\n$ git status\n\ngit status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n        .gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nThe subfolder “results” and it’s contents are ignored. This is handy for keeping all of your data in a single folder. You simply add the data folder to your .gitignore and the contents will not be accidentally pushed.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#pulling-changes-from-github",
    "href": "materials/03-remote-hosting.html#pulling-changes-from-github",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "3.4 Pulling changes from GitHub",
    "text": "3.4 Pulling changes from GitHub\nGit allows you to work collaboratively, with multiple people making changes to the same repo and sharing those changes through GitHub. We’ve seen how to create a repository and push changes to it; now we will see how to pull another person’s changes from Github.\nStart by opening a second terminal window. This window will represent your colleague, working on another computer. In the second window, navigate to the folder one level “up” in the directory tree from where you have your planets repository.\n\n$ ls\n\nplanets\nYou don’t want to overwrite your first version of planets.git, so you will clone the planets repository to a different location.\n\n$ mkdir collab\n$ cd collab\n\nClone the planets repo substituting in your Github user name:\n\ngit clone https://github.com/&lt;yourusername&gt;/planets.git\n\nCloning into 'planets'...\nremote: Enumerating objects: 10, done.\nremote: Counting objects: 100% (10/10), done.\nremote: Compressing objects: 100% (5/5), done.\nremote: Total 10 (delta 2), reused 10 (delta 2), pack-reused 0\nReceiving objects: 100% (10/10), done.\nResolving deltas: 100% (2/2), done.\n\n\n\n\n\n\nNote\n\n\n\nYou won’t need to give anyone access on GitHub, because GitHub will recognize both contributors as you.\n\n\nYou can now make a change in your clone of the original repository, exactly the same way as we’ve been doing before. Add a line of text to a .txt file and save in your cloned repository.\n\n$ cat pluto.txt\n\nIt is so a planet!\n\n$ git add pluto.txt\n$ git commit -m \"Add notes about Pluto\"\n\n 1 file changed, 1 insertion(+)\n create mode 100644 pluto.txt\n\n$ git push origin main\n\nEnumerating objects: 4, done.\nCounting objects: 100% (4/4), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 302 bytes | 302.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo https://github.com/&lt;yourusername&gt;/planets.git\n   3abcea2..b792d59  main -&gt; main\n\n\n\n\n\n\nNote\n\n\n\nWe didn’t have to create a remote called origin: Git uses this name by default when we clone a repository. (This is why origin was a sensible choice earlier when we were setting up remotes by hand.)\n\n\nTo download the your changes from GitHub, switch back to the bash window (where you were working in your original repository) and enter:\n\n$ git pull origin main\n\nFrom https://github.com/&lt;yourusername&gt;/planets\n * branch            main       -&gt; FETCH_HEAD\nUpdating 3abcea2..b792d59\nFast-forward\n pluto.txt | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 pluto.txt\nNow the three repositories (original local, second local, and the one on GitHub) are back in sync.",
    "crumbs": [
      "About The Workshop",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Introduction to Version Control",
    "section": "",
    "text": "Government employees, public and members of the private sector are encouraged to contribute to the repository by forking and submitting a pull request.\n(If you are new to GitHub, you might start with a basic tutorial and check out a more detailed guide to pull requests.)\nPull requests will be evaluated by the repository guardians on a schedule and if deemed beneficial will be committed to the master.\nAll contributors retain the original copyright to their stuff, but by contributing to this project, you grant a world-wide, royalty-free, perpetual, irrevocable, non-exclusive, transferable license to all users under the terms of the license under which this project is distributed.\n\nThis project was created using the bcgovr package."
  },
  {
    "objectID": "CONTRIBUTING.html#how-to-contribute",
    "href": "CONTRIBUTING.html#how-to-contribute",
    "title": "Introduction to Version Control",
    "section": "",
    "text": "Government employees, public and members of the private sector are encouraged to contribute to the repository by forking and submitting a pull request.\n(If you are new to GitHub, you might start with a basic tutorial and check out a more detailed guide to pull requests.)\nPull requests will be evaluated by the repository guardians on a schedule and if deemed beneficial will be committed to the master.\nAll contributors retain the original copyright to their stuff, but by contributing to this project, you grant a world-wide, royalty-free, perpetual, irrevocable, non-exclusive, transferable license to all users under the terms of the license under which this project is distributed.\n\nThis project was created using the bcgovr package."
  }
]